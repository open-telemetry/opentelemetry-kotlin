package io.opentelemetry.kotlin.semconv

/**
 * Autogenerated OpenTelemetry semantic conventions for 'jvm'.
 *
 * DO NOT EDIT - AUTOGENERATED FILE
 */
@Suppress("unused")
object JvmAttributes {
  

    /**
    * <p>Name of the buffer pool.</p>
    * <p>Notes:</p>
    * <p>Pool names are generally obtained via <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.management/java/lang/management/BufferPoolMXBean.html#getName()">BufferPoolMXBean#getName()</a>.</p>
    */
    @IncubatingApi
    const val JVM_BUFFER_POOL_NAME: String = "jvm.buffer.pool.name"

    /**
    * <p>Name of the garbage collector action.</p>
    * <p>Notes:</p>
    * <p>Garbage collector action is generally obtained via <a href="https://docs.oracle.com/en/java/javase/11/docs/api/jdk.management/com/sun/management/GarbageCollectionNotificationInfo.html#getGcAction()">GarbageCollectionNotificationInfo#getGcAction()</a>.</p>
    */
    const val JVM_GC_ACTION: String = "jvm.gc.action"

    /**
    * <p>Name of the garbage collector cause.</p>
    * <p>Notes:</p>
    * <p>Garbage collector cause is generally obtained via <a href="https://docs.oracle.com/en/java/javase/11/docs/api/jdk.management/com/sun/management/GarbageCollectionNotificationInfo.html#getGcCause()">GarbageCollectionNotificationInfo#getGcCause()</a>.</p>
    */
    @IncubatingApi
    const val JVM_GC_CAUSE: String = "jvm.gc.cause"

    /**
    * <p>Name of the garbage collector.</p>
    * <p>Notes:</p>
    * <p>Garbage collector name is generally obtained via <a href="https://docs.oracle.com/en/java/javase/11/docs/api/jdk.management/com/sun/management/GarbageCollectionNotificationInfo.html#getGcName()">GarbageCollectionNotificationInfo#getGcName()</a>.</p>
    */
    const val JVM_GC_NAME: String = "jvm.gc.name"

    /**
    * <p>Name of the memory pool.</p>
    * <p>Notes:</p>
    * <p>Pool names are generally obtained via <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.management/java/lang/management/MemoryPoolMXBean.html#getName()">MemoryPoolMXBean#getName()</a>.</p>
    */
    const val JVM_MEMORY_POOL_NAME: String = "jvm.memory.pool.name"

    /**
    * <p>The type of memory.</p>
    */
    const val JVM_MEMORY_TYPE: String = "jvm.memory.type"

    /**
    * <p>Whether the thread is daemon or not.</p>
    */
    const val JVM_THREAD_DAEMON: String = "jvm.thread.daemon"

    /**
    * <p>State of the thread.</p>
    */
    const val JVM_THREAD_STATE: String = "jvm.thread.state"

    /**
    * <p>JVM_MEMORY_TYPE</p>
    */
    enum class JvmMemoryTypeValues(val value: String) {

        /**
        * <p>Heap memory.</p>
        */
        HEAP("heap"),

        /**
        * <p>Non-heap memory</p>
        */
        NON_HEAP("non_heap"),
    }

    /**
    * <p>JVM_THREAD_STATE</p>
    */
    enum class JvmThreadStateValues(val value: String) {

        /**
        * <p>A thread that has not yet started is in this state.</p>
        */
        NEW("new"),

        /**
        * <p>A thread executing in the Java virtual machine is in this state.</p>
        */
        RUNNABLE("runnable"),

        /**
        * <p>A thread that is blocked waiting for a monitor lock is in this state.</p>
        */
        BLOCKED("blocked"),

        /**
        * <p>A thread that is waiting indefinitely for another thread to perform a particular action is in this state.</p>
        */
        WAITING("waiting"),

        /**
        * <p>A thread that is waiting for another thread to perform an action for up to a specified waiting time is in this state.</p>
        */
        TIMED_WAITING("timed_waiting"),

        /**
        * <p>A thread that has exited is in this state.</p>
        */
        TERMINATED("terminated"),
    }
}
